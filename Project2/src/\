#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>
#include <iostream>
#include <string>

#ifdef __APPLE__
#include <OpenGL/gl3.h>
#include <OpenGL/gl3ext.h>
#else
#include <windows.h>
#include <GL/gl.h>
#endif

#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/freeglut.h>
#endif

#include "cyTriMesh.h"
#include "cyGL.h"
#include "cyMatrix.h"

#define PI 3.141592653589

using namespace std;
using namespace cy;

////////////////////////////////////////////////////////////////////////////////
//GLOBAL VARIABLE
////////////////////////////////////////////////////////////////////////////////
TriMesh *g_mesh;
GLSLProgram *g_program;
float g_rot1 = 0.0, g_rot2 = 0.0;
float g_trans = 0.0;
unsigned g_screen_width = 800;
unsigned g_screen_height = 600;

////////////////////////////////////////////////////////////////////////////////
void onDisplay(){
    glClear(GL_COLOR_BUFFER_BIT);
    glClearColor(0.0f, 0.0f, 0.0f ,1.0f);

     //Generate a vertex buffer and set its data using the vertices read from .obj file
    GLuint VBO;
    glGenBuffers(1, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(Point3f) * g_mesh->NV(), &g_mesh->V(0), GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
    glDrawArrays(GL_POINTS, 0, g_mesh->NV());

    glutSwapBuffers();
}

void onMouse(int button, int state, int x, int y){
    float dist = -50.0;
    static Point2f dist_record_coord;
    static Point2f angle_record_coord;
    static bool dist_record = false;
    static bool angle_record = false;
    Point3f g = Point3f(0.0, 0.0, -1.0); // gaze direction
    Point3f t = Point3f(0.0, 1.0, 0.0); // view up direction

    if(button == GLUT_LEFT_BUTTON){
        if(state == GLUT_DOWN){
            if(!angle_record){
                angle_record_coord = Point2f(x, y);
                cout << "x = " << x << ",y =" << y << endl;
                angle_record = true;
            }
        }
        else{
           angle_record = false;
        }
        g.x = x - angle_record_coord.x;
        g.y = y - angle_record_coord.y;

    }
    else if(button == GLUT_RIGHT_BUTTON){
        if(state == GLUT_DOWN){
            if(!dist_record){
                dist_record_coord = Point2f(x,y);
                cout << "x = " << x << ",y =" << y << endl;
                dist_record = true;
            }
        }
        else{
            cout << "dist = " << dist << endl;
            dist_record = false;
        }
        dist = (Point2f(x,y) - dist_record_coord).Length();

    }
    //transformations
    Point3f w = -g / g.Length();
    Point3f u = t.Cross(w) / (t.Cross(w)).Length();
    Point3f v = w.Cross(u);
    Point3f e(0.0, 0.0, -dist);

    Matrix4<float> view,projection, modelViewProjection, rotation, scale, translation;
    view.Set(u, v, w, e);
    float aspect = (float)g_screen_width/(float)g_screen_height;
    projection.SetPerspective(PI/3, aspect, 20, -20);
    modelViewProjection = projection * view;


    cout << modelViewProjection.data[0] << ", " << modelViewProjection.data[4] << ", " << modelViewProjection.data[8] << ", " << modelViewProjection.data[12] << endl;
    cout << modelViewProjection.data[1] << ", " << modelViewProjection.data[5] << ", " << modelViewProjection.data[9] << ", " << modelViewProjection.data[13] << endl;
    cout << modelViewProjection.data[2] << ", " << modelViewProjection.data[6] << ", " << modelViewProjection.data[10] << ", " << modelViewProjection.data[14] << endl;
    cout << modelViewProjection.data[3] << ", " << modelViewProjection.data[7] << ", " << modelViewProjection.data[11] << ", " << modelViewProjection.data[15] << endl;
    g_program->SetUniformMatrix4(0, modelViewProjection.data);
}

void onKeyboard(unsigned char key, int x, int y){
    if(key == 27){
        exit(0);
    }
}


void timeout(int value){
    glutPostRedisplay();
	glutTimerFunc(1000, timeout, 0);
}

int main(int argc, char *argv[]){
    //reading and parsing of the obj file
    string obj_filename;
    if(argc == 2){
        obj_filename = string(argv[1]);
    }
    else{
        cerr << "please input the obj filename" << endl;
        return 0;
    }

    g_mesh = new TriMesh();
    if(!g_mesh->LoadFromFileObj(obj_filename.c_str(), false)){
        cerr << "failure of loading the obj file" << endl;
    }

    srand(time(NULL));
    glutInit(&argc, argv);
    //generate and bind a vertex array object
//    GLenum err = glewInit();
//    if(GLEW_OK != err){
        /* Problem: glewInit failed, something is seriously wrong */
//        cerr << "Error: " << glewGetErrorString(err) << endl;
//        return 1;
//    }
//    cout << "Status: Using GLEW " << glewGetString(GLEW_VERSION) << endl;

   glutInitWindowSize(g_screen_width, g_screen_height);
    glutCreateWindow("Project 1 of CS6610");

    //Generate and bind a vertex array object
   GLboolean isVAO;
   const GLubyte *strExt;
   const GLubyte *strVersion;
   float myGLVersion;
   strExt = glGetString (GL_EXTENSIONS);
   strVersion = glGetString(GL_VERSION);
   sscanf((char *)strVersion, "%f", &myGLVersion);
   cout << "myGLVersion = " << myGLVersion << endl;
   isVAO = gluCheckExtension((const GLubyte*)"GL_APPLE_vertex_array_object", strExt);
    if(!isVAO){
        cerr << "isVAO false" << endl;
        return 1;
    }
    GLuint m_VAO;
    GLuint vertexBuffer;
    glGenVertexArrays(1, &m_VAO);
    glBindVertexArray(m_VAO);
    glBindVertexArray(0);

    //glsl shader
    g_program = new GLSLProgram();
    glBindAttribLocation(g_program->GetID(), 0, "pos");
    g_program->BuildFiles("../glsl/vert.txt", "../glsl/frag.txt");
    g_program->RegisterUniform(0, "modelViewProjection");
    g_program->Bind();

    glutDisplayFunc(onDisplay);
    glutKeyboardFunc(onKeyboard);
    glutMouseFunc(onMouse);
	glutTimerFunc(1000, timeout, 0);
    glutMainLoop();
}
